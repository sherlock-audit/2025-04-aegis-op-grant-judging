Tangy Dijon Fly

High

# Redeemer Doesn't Pay Any Fee

### Summary

When redeeming, the user receives collateral equivalent to the amount of `YUSD` they requested, which means the user does not incur any fees. Instead, the fee is effectively taken by unburning a portion of the `YUSD` that the user sent. Consequently, this fee does not come from actual collateral, resulting in the over-minting of `YUSD` beyond the collateral that the protocol holds.

### Root Cause

In the `approveRedeemRequest()` function, as seen at [line 324](https://github.com/sherlock-audit/2025-04-aegis-op-grant/tree/main/aegis-contracts/contracts/AegisMinting.sol#L324), the `collateralAmount` is calculated based on `request.order.yusdAmount`, and this entire amount is sent to the user at line 354. As a result, the user incurs no fees.

Instead, the fee is generated by unburning a portion of the `YUSD` that the user sent, as indicated at line 346.

In fact, the collateral equivalent to the amount of `YUSD` the user requested is entirely sent to the user. Therefore, all the `YUSD` that the user sent should be burned. However, some of the `YUSD` is not burned and is instead used as a fee, leading to the over-minting of `YUSD` beyond the collateral that the protocol holds.

A more appropriate approach would be to reduce the collateral amount that the user receives, thereby ensuring that users bear the cost of the fees.

```solidity
      function approveRedeemRequest(string calldata requestId, uint256 amount) external nonReentrant onlyRole(FUNDS_MANAGER_ROLE) whenRedeemUnpaused {
        ...

324     uint256 collateralAmount = _calculateRedeemMinCollateralAmount(request.order.collateralAsset, amount, request.order.yusdAmount);
        
        ...

        // Take a fee, if it's applicable
346     (uint256 burnAmount, uint256 fee) = _calculateInsuranceFundFeeFromAmount(request.order.yusdAmount, redeemFeeBP);
        if (fee > 0) {
          yusd.safeTransfer(insuranceFundAddress, fee);
        }

        ...

354     IERC20(request.order.collateralAsset).safeTransfer(request.order.userWallet, collateralAmount);
        yusd.burn(burnAmount);

        emit ApproveRedeemRequest(requestId, _msgSender(), request.order.userWallet, request.order.collateralAsset, collateralAmount, burnAmount, fee);
      }
```

### Internal pre-conditions

### External pre-conditions

### Attack Path

### Impact

Redeemers do not incur any fees, and since the fees do not come from actual collateral, this results in the over-minting of `YUSD` beyond the collateral that the protocol holds.

### PoC

### Mitigation

Reduce the collateral amount that the redeemer receives.